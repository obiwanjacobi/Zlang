# Zlang Compiler

- [Checked Functions](checked.md)
- [Meta Programming](meta.md)
- [Conditional Compilation](conditional.md)
- [Libraries](libraries.md)
- [Packages](packages.md)
- [Extensions](extensions.md)
- [Compiler Options](options.md)
- [Assembly](assembly.md)

---

> Compiler as static analyzer / linter

> Compiler as language Server (LSP)

> Compiler as (remote) debugger. How to interface with the hardware? See also Z80 In-Circuit-Emulation

> Compiler as (remote) console. Coded/hashed errors are transmitted (Serial) to the compiler that can translate it into readable diagnostic text. This way the debug binary does not explode.

> Compiler as Assembler (byte-code?)

> Compiler as linker (late optimizations)

> Compiler as REPL (because we support Meta)

> Compiler as Language VM? (used by REPL) - zs-script

> Compiler as profiler?

> Compiler as build-system? Use REPL/VM to execute zs-script using build-task lib...?

> Semantic compiler rules as functions available to code (traits?).

---

> Literal strings can add up. How to optimize? (interning?, string-builder for efficient construction?)
